/**
 * generated by Xtext 2.13.0
 */
package edu.ucf.cs.whilelang.whileLang.impl;

import edu.ucf.cs.whilelang.whileLang.*;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;

import org.eclipse.emf.ecore.impl.EFactoryImpl;

import org.eclipse.emf.ecore.plugin.EcorePlugin;

/**
 * <!-- begin-user-doc -->
 * An implementation of the model <b>Factory</b>.
 * <!-- end-user-doc -->
 * @generated
 */
public class WhileLangFactoryImpl extends EFactoryImpl implements WhileLangFactory
{
  /**
   * Creates the default factory implementation.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public static WhileLangFactory init()
  {
    try
    {
      WhileLangFactory theWhileLangFactory = (WhileLangFactory)EPackage.Registry.INSTANCE.getEFactory(WhileLangPackage.eNS_URI);
      if (theWhileLangFactory != null)
      {
        return theWhileLangFactory;
      }
    }
    catch (Exception exception)
    {
      EcorePlugin.INSTANCE.log(exception);
    }
    return new WhileLangFactoryImpl();
  }

  /**
   * Creates an instance of the factory.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public WhileLangFactoryImpl()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EObject create(EClass eClass)
  {
    switch (eClass.getClassifierID())
    {
      case WhileLangPackage.PROGRAM: return createProgram();
      case WhileLangPackage.FORMALS: return createFormals();
      case WhileLangPackage.S: return createS();
      case WhileLangPackage.COMPOUND_S: return createCompoundS();
      case WhileLangPackage.ASSIGN_S: return createAssignS();
      case WhileLangPackage.SKIP_S: return createSkipS();
      case WhileLangPackage.WHILE_S: return createWhileS();
      case WhileLangPackage.IF_S: return createIfS();
      case WhileLangPackage.LABELED_EXP: return createLabeledExp();
      case WhileLangPackage.EXPR: return createExpr();
      case WhileLangPackage.VAR_REF_EXPR: return createVarRefExpr();
      case WhileLangPackage.SIGNED_NUM: return createSignedNum();
      case WhileLangPackage.NUM_LIT_EXPR: return createNumLitExpr();
      case WhileLangPackage.BOOL_LIT_EXPR: return createBoolLitExpr();
      case WhileLangPackage.NOT_EXPR: return createNotExpr();
      case WhileLangPackage.ELEMENTARY_BLOCK: return createElementaryBlock();
      case WhileLangPackage.BDISJ: return createBDisj();
      case WhileLangPackage.BCONJ: return createBConj();
      case WhileLangPackage.BREL_EXP: return createBRelExp();
      case WhileLangPackage.AEXPRESSION: return createAExpression();
      case WhileLangPackage.FACTOR: return createFactor();
      default:
        throw new IllegalArgumentException("The class '" + eClass.getName() + "' is not a valid classifier");
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public Program createProgram()
  {
    ProgramImpl program = new ProgramImpl();
    return program;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public Formals createFormals()
  {
    FormalsImpl formals = new FormalsImpl();
    return formals;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public S createS()
  {
    SImpl s = new SImpl();
    return s;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public CompoundS createCompoundS()
  {
    CompoundSImpl compoundS = new CompoundSImpl();
    return compoundS;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public AssignS createAssignS()
  {
    AssignSImpl assignS = new AssignSImpl();
    return assignS;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public SkipS createSkipS()
  {
    SkipSImpl skipS = new SkipSImpl();
    return skipS;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public WhileS createWhileS()
  {
    WhileSImpl whileS = new WhileSImpl();
    return whileS;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public IfS createIfS()
  {
    IfSImpl ifS = new IfSImpl();
    return ifS;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public LabeledExp createLabeledExp()
  {
    LabeledExpImpl labeledExp = new LabeledExpImpl();
    return labeledExp;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public Expr createExpr()
  {
    ExprImpl expr = new ExprImpl();
    return expr;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VarRefExpr createVarRefExpr()
  {
    VarRefExprImpl varRefExpr = new VarRefExprImpl();
    return varRefExpr;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public SignedNum createSignedNum()
  {
    SignedNumImpl signedNum = new SignedNumImpl();
    return signedNum;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public NumLitExpr createNumLitExpr()
  {
    NumLitExprImpl numLitExpr = new NumLitExprImpl();
    return numLitExpr;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public BoolLitExpr createBoolLitExpr()
  {
    BoolLitExprImpl boolLitExpr = new BoolLitExprImpl();
    return boolLitExpr;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public NotExpr createNotExpr()
  {
    NotExprImpl notExpr = new NotExprImpl();
    return notExpr;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public ElementaryBlock createElementaryBlock()
  {
    ElementaryBlockImpl elementaryBlock = new ElementaryBlockImpl();
    return elementaryBlock;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public BDisj createBDisj()
  {
    BDisjImpl bDisj = new BDisjImpl();
    return bDisj;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public BConj createBConj()
  {
    BConjImpl bConj = new BConjImpl();
    return bConj;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public BRelExp createBRelExp()
  {
    BRelExpImpl bRelExp = new BRelExpImpl();
    return bRelExp;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public AExpression createAExpression()
  {
    AExpressionImpl aExpression = new AExpressionImpl();
    return aExpression;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public Factor createFactor()
  {
    FactorImpl factor = new FactorImpl();
    return factor;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public WhileLangPackage getWhileLangPackage()
  {
    return (WhileLangPackage)getEPackage();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @deprecated
   * @generated
   */
  @Deprecated
  public static WhileLangPackage getPackage()
  {
    return WhileLangPackage.eINSTANCE;
  }

} //WhileLangFactoryImpl
