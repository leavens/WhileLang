/*
 * generated by Xtext 2.13.0
 */
package edu.ucf.cs.whilelang.serializer;

import com.google.inject.Inject;
import edu.ucf.cs.whilelang.services.WhileLangGrammarAccess;
import edu.ucf.cs.whilelang.whileLang.AExpression;
import edu.ucf.cs.whilelang.whileLang.ATerm;
import edu.ucf.cs.whilelang.whileLang.AssignS;
import edu.ucf.cs.whilelang.whileLang.BCompExp;
import edu.ucf.cs.whilelang.whileLang.BExpression;
import edu.ucf.cs.whilelang.whileLang.BPrimary;
import edu.ucf.cs.whilelang.whileLang.BTerm;
import edu.ucf.cs.whilelang.whileLang.CompoundS;
import edu.ucf.cs.whilelang.whileLang.IfS;
import edu.ucf.cs.whilelang.whileLang.NotExpr;
import edu.ucf.cs.whilelang.whileLang.NumLitExpr;
import edu.ucf.cs.whilelang.whileLang.SkipS;
import edu.ucf.cs.whilelang.whileLang.VarRefExpr;
import edu.ucf.cs.whilelang.whileLang.WhileLangPackage;
import edu.ucf.cs.whilelang.whileLang.WhileS;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class WhileLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private WhileLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == WhileLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case WhileLangPackage.AEXPRESSION:
				sequence_AExpression(context, (AExpression) semanticObject); 
				return; 
			case WhileLangPackage.ATERM:
				sequence_ATerm(context, (ATerm) semanticObject); 
				return; 
			case WhileLangPackage.ASSIGN_S:
				sequence_Assignment(context, (AssignS) semanticObject); 
				return; 
			case WhileLangPackage.BCOMP_EXP:
				sequence_BCompExp(context, (BCompExp) semanticObject); 
				return; 
			case WhileLangPackage.BEXPRESSION:
				sequence_BExpression(context, (BExpression) semanticObject); 
				return; 
			case WhileLangPackage.BPRIMARY:
				sequence_BPrimary(context, (BPrimary) semanticObject); 
				return; 
			case WhileLangPackage.BTERM:
				sequence_BTerm(context, (BTerm) semanticObject); 
				return; 
			case WhileLangPackage.COMPOUND_S:
				sequence_Block(context, (CompoundS) semanticObject); 
				return; 
			case WhileLangPackage.IF_S:
				sequence_If(context, (IfS) semanticObject); 
				return; 
			case WhileLangPackage.NOT_EXPR:
				sequence_NotExpr(context, (NotExpr) semanticObject); 
				return; 
			case WhileLangPackage.NUM_LIT_EXPR:
				sequence_NumLitExpr(context, (NumLitExpr) semanticObject); 
				return; 
			case WhileLangPackage.SKIP_S:
				sequence_Skip(context, (SkipS) semanticObject); 
				return; 
			case WhileLangPackage.VAR_REF_EXPR:
				sequence_VarRefExpr(context, (VarRefExpr) semanticObject); 
				return; 
			case WhileLangPackage.WHILE_S:
				sequence_While(context, (WhileS) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AExpression returns AExpression
	 *     AExpression.AExpression_1_0 returns AExpression
	 *     ATerm returns AExpression
	 *     ATerm.ATerm_1_0 returns AExpression
	 *     APrimary returns AExpression
	 *
	 * Constraint:
	 *     (left=AExpression_AExpression_1_0 op=OPPLUS right=AExpression)
	 */
	protected void sequence_AExpression(ISerializationContext context, AExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.AEXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.AEXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.AEXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.AEXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.AEXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.AEXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAExpressionAccess().getAExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAExpressionAccess().getOpOPPLUSTerminalRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAExpressionAccess().getRightAExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AExpression returns ATerm
	 *     AExpression.AExpression_1_0 returns ATerm
	 *     ATerm returns ATerm
	 *     ATerm.ATerm_1_0 returns ATerm
	 *     APrimary returns ATerm
	 *
	 * Constraint:
	 *     (left=ATerm_ATerm_1_0 op=OPMUL right=ATerm)
	 */
	protected void sequence_ATerm(ISerializationContext context, ATerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.ATERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.ATERM__LEFT));
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.ATERM__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.ATERM__OP));
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.ATERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.ATERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getATermAccess().getATermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getATermAccess().getOpOPMULTerminalRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getATermAccess().getRightATermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns AssignS
	 *     Stmt returns AssignS
	 *     Assignment returns AssignS
	 *
	 * Constraint:
	 *     (var=ID aexp=AExpression)
	 */
	protected void sequence_Assignment(ISerializationContext context, AssignS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.ASSIGN_S__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.ASSIGN_S__VAR));
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.ASSIGN_S__AEXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.ASSIGN_S__AEXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getVarIDTerminalRuleCall_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getAssignmentAccess().getAexpAExpressionParserRuleCall_2_0(), semanticObject.getAexp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BExpression returns BCompExp
	 *     BExpression.BExpression_1_0 returns BCompExp
	 *     BTerm returns BCompExp
	 *     BTerm.BTerm_1_0 returns BCompExp
	 *     BRelExp returns BCompExp
	 *     BCompExp returns BCompExp
	 *
	 * Constraint:
	 *     (left=AExpression op=OP_R right=AExpression)
	 */
	protected void sequence_BCompExp(ISerializationContext context, BCompExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.BCOMP_EXP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.BCOMP_EXP__LEFT));
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.BCOMP_EXP__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.BCOMP_EXP__OP));
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.BCOMP_EXP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.BCOMP_EXP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBCompExpAccess().getLeftAExpressionParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBCompExpAccess().getOpOP_RTerminalRuleCall_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getBCompExpAccess().getRightAExpressionParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BExpression returns BExpression
	 *     BExpression.BExpression_1_0 returns BExpression
	 *     BTerm returns BExpression
	 *     BTerm.BTerm_1_0 returns BExpression
	 *     BRelExp returns BExpression
	 *
	 * Constraint:
	 *     (left=BExpression_BExpression_1_0 op=OR right=BExpression)
	 */
	protected void sequence_BExpression(ISerializationContext context, BExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.BEXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.BEXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.BEXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.BEXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.BEXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.BEXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBExpressionAccess().getBExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBExpressionAccess().getOpORTerminalRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getBExpressionAccess().getRightBExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BExpression returns BPrimary
	 *     BExpression.BExpression_1_0 returns BPrimary
	 *     BTerm returns BPrimary
	 *     BTerm.BTerm_1_0 returns BPrimary
	 *     BRelExp returns BPrimary
	 *     BPrimary returns BPrimary
	 *
	 * Constraint:
	 *     (bval='true' | bval='false')
	 */
	protected void sequence_BPrimary(ISerializationContext context, BPrimary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BExpression returns BTerm
	 *     BExpression.BExpression_1_0 returns BTerm
	 *     BTerm returns BTerm
	 *     BTerm.BTerm_1_0 returns BTerm
	 *     BRelExp returns BTerm
	 *
	 * Constraint:
	 *     (left=BTerm_BTerm_1_0 op=AND right=BTerm)
	 */
	protected void sequence_BTerm(ISerializationContext context, BTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.BTERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.BTERM__LEFT));
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.BTERM__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.BTERM__OP));
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.BTERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.BTERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBTermAccess().getBTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBTermAccess().getOpANDTerminalRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getBTermAccess().getRightBTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns CompoundS
	 *     Stmt returns CompoundS
	 *     Block returns CompoundS
	 *
	 * Constraint:
	 *     (stmts+=Stmt stmts+=Stmt*)
	 */
	protected void sequence_Block(ISerializationContext context, CompoundS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns IfS
	 *     Stmt returns IfS
	 *     If returns IfS
	 *
	 * Constraint:
	 *     (bexp=BExpression s1=Block s2=Block)
	 */
	protected void sequence_If(ISerializationContext context, IfS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.IF_S__BEXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.IF_S__BEXP));
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.IF_S__S1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.IF_S__S1));
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.IF_S__S2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.IF_S__S2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfAccess().getBexpBExpressionParserRuleCall_1_0(), semanticObject.getBexp());
		feeder.accept(grammarAccess.getIfAccess().getS1BlockParserRuleCall_3_0(), semanticObject.getS1());
		feeder.accept(grammarAccess.getIfAccess().getS2BlockParserRuleCall_5_0(), semanticObject.getS2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BExpression returns NotExpr
	 *     BExpression.BExpression_1_0 returns NotExpr
	 *     BTerm returns NotExpr
	 *     BTerm.BTerm_1_0 returns NotExpr
	 *     BRelExp returns NotExpr
	 *     NotExpr returns NotExpr
	 *
	 * Constraint:
	 *     bexp=BRelExp
	 */
	protected void sequence_NotExpr(ISerializationContext context, NotExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.NOT_EXPR__BEXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.NOT_EXPR__BEXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotExprAccess().getBexpBRelExpParserRuleCall_1_0(), semanticObject.getBexp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AExpression returns NumLitExpr
	 *     AExpression.AExpression_1_0 returns NumLitExpr
	 *     ATerm returns NumLitExpr
	 *     ATerm.ATerm_1_0 returns NumLitExpr
	 *     APrimary returns NumLitExpr
	 *     NumLitExpr returns NumLitExpr
	 *
	 * Constraint:
	 *     (negated?='-'? val=INT)
	 */
	protected void sequence_NumLitExpr(ISerializationContext context, NumLitExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns SkipS
	 *     Stmt returns SkipS
	 *     Skip returns SkipS
	 *
	 * Constraint:
	 *     {SkipS}
	 */
	protected void sequence_Skip(ISerializationContext context, SkipS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AExpression returns VarRefExpr
	 *     AExpression.AExpression_1_0 returns VarRefExpr
	 *     ATerm returns VarRefExpr
	 *     ATerm.ATerm_1_0 returns VarRefExpr
	 *     APrimary returns VarRefExpr
	 *     VarRefExpr returns VarRefExpr
	 *
	 * Constraint:
	 *     var=ID
	 */
	protected void sequence_VarRefExpr(ISerializationContext context, VarRefExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.VAR_REF_EXPR__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.VAR_REF_EXPR__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarRefExprAccess().getVarIDTerminalRuleCall_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns WhileS
	 *     Stmt returns WhileS
	 *     While returns WhileS
	 *
	 * Constraint:
	 *     (bexp=BExpression block=Block)
	 */
	protected void sequence_While(ISerializationContext context, WhileS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.WHILE_S__BEXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.WHILE_S__BEXP));
			if (transientValues.isValueTransient(semanticObject, WhileLangPackage.Literals.WHILE_S__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WhileLangPackage.Literals.WHILE_S__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileAccess().getBexpBExpressionParserRuleCall_1_0(), semanticObject.getBexp());
		feeder.accept(grammarAccess.getWhileAccess().getBlockBlockParserRuleCall_3_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
}
